# Modularity Check Rule

## Always Check for Existing Modules Before Building

Before implementing any new functionality, ALWAYS search the codebase for existing modules that might already handle the same or similar functionality.

### Search Patterns to Use:
1. **Function names**: Search for function names that might already exist
2. **File patterns**: Look for files in relevant directories (e.g., `src/lib/`, `src/components/`, `src/app/api/`)
3. **Type definitions**: Check if types/interfaces already exist
4. **Utility functions**: Look for existing utility functions that could be reused

### Common Module Locations:
- **API Routes**: `src/app/api/` - Check for existing endpoints
- **Business Logic**: `src/lib/` - Check for existing utilities and services
- **Components**: `src/components/` - Check for existing UI components
- **Types**: `src/types/` - Check for existing type definitions
- **Hooks**: `src/hooks/` - Check for existing React hooks
- **Utils**: `src/lib/utils.ts` - Check for existing utility functions

### Before Building New Modules:
1. Search the codebase for similar functionality
2. Check if existing modules can be extended instead of creating new ones
3. Look for patterns that could be abstracted into reusable modules
4. Consider if the functionality belongs in an existing module

### Examples of What to Check:
- **Data fetching**: Look for existing API clients or data fetchers
- **Validation**: Check for existing Zod schemas or validation functions
- **UI components**: Look for existing components that could be reused
- **Business logic**: Check for existing algorithms or calculations
- **Type definitions**: Look for existing interfaces or types

### When to Create New Modules:
- No existing functionality found
- Existing modules are tightly coupled and can't be extended
- New functionality is significantly different from existing patterns
- Creating a new module improves code organization

### When to Extend Existing Modules:
- Similar functionality exists but needs additional features
- Existing module can be generalized to handle new use cases
- New functionality fits naturally into existing module's responsibility
- Extending reduces code duplication

This rule helps maintain code quality, reduce duplication, and ensure we're building on existing foundations rather than reinventing the wheel.